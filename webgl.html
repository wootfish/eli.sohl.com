<!doctype html>
<html lang="en">
    <head>
        <title>eli dot sohl dot com</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
        <link rel="stylesheet" href="./style.css"></link>
    </head>


    <body>
        <canvas id="glcanvas"></canvas>
    </body>


    <script id="2d-vertex-shader" type="notjs">



// passthrough vertex shader for RD effect
attribute vec2 a_position;

void main() {
    gl_Position = vec4(a_position, 0, 1);
}



    </script>
    <script id="2d-fragment-noise-shader" type="notjs">



// shader for initializing gray-scott data array from smooth noise
// random, noise, and fbm functions via https://thebookofshaders.com/
precision mediump float;

//uniform sampler2D u_grayscott;
uniform vec2 u_resolution;
uniform float t;

//uniform float u_da;
//uniform float u_db;
//uniform float u_feed;
//uniform float u_kill;


//out vec4 fragmentColor;



/******* 4D simplex noise implementation begins *********/
// (reference: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83 )
vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
float permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}
vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}
float taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}

vec4 grad4(float j, vec4 ip) {
    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);
    vec4 p,s;

    p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;
    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);
    s = vec4(lessThan(p, vec4(0.0)));
    p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; 

    return p;
}

float snoise(vec4 v) {
    const vec2  C = vec2( 0.138196601125010504,  // (5 - sqrt(5))/20  G4
                        0.309016994374947451); // (sqrt(5) - 1)/4   F4
    // First corner
    vec4 i  = floor(v + dot(v, C.yyyy) );
    vec4 x0 = v -   i + dot(i, C.xxxx);

    // Other corners

    // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)
    vec4 i0;

    vec3 isX = step( x0.yzw, x0.xxx );
    vec3 isYZ = step( x0.zww, x0.yyz );
    //  i0.x = dot( isX, vec3( 1.0 ) );
    i0.x = isX.x + isX.y + isX.z;
    i0.yzw = 1.0 - isX;

    //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );
    i0.y += isYZ.x + isYZ.y;
    i0.zw += 1.0 - isYZ.xy;

    i0.z += isYZ.z;
    i0.w += 1.0 - isYZ.z;

    // i0 now contains the unique values 0,1,2,3 in each channel
    vec4 i3 = clamp( i0, 0.0, 1.0 );
    vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );
    vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );

    //  x0 = x0 - 0.0 + 0.0 * C 
    vec4 x1 = x0 - i1 + 1.0 * C.xxxx;
    vec4 x2 = x0 - i2 + 2.0 * C.xxxx;
    vec4 x3 = x0 - i3 + 3.0 * C.xxxx;
    vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;

    // Permutations
    i = mod(i, 289.0); 
    float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);
    vec4 j1 = permute( permute( permute( permute (
             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))
           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))
           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))
           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));
    // Gradients
    // ( 7*7*6 points uniformly over a cube, mapped onto a 4-octahedron.)
    // 7*7*6 = 294, which is close to the ring size 17*17 = 289.

    vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;

    vec4 p0 = grad4(j0,   ip);
    vec4 p1 = grad4(j1.x, ip);
    vec4 p2 = grad4(j1.y, ip);
    vec4 p3 = grad4(j1.z, ip);
    vec4 p4 = grad4(j1.w, ip);

    // Normalise gradients
    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;
    p4 *= taylorInvSqrt(dot(p4,p4));

    // Mix contributions from the five corners
    vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);
    vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);
    m0 = m0 * m0;
    m1 = m1 * m1;
    return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))
               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;
}


/********** 4D simplex noise implementation ends ***********/


//float mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
//vec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
//vec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}
//
//float noise(vec3 p){
//    vec3 a = floor(p);
//    vec3 d = p - a;
//    d = d * d * (3.0 - 2.0 * d);
//
//    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);
//    vec4 k1 = perm(b.xyxy);
//    vec4 k2 = perm(k1.xyxy + b.zzww);
//
//    vec4 c = k2 + a.zzzz;
//    vec4 k3 = perm(c);
//    vec4 k4 = perm(c + 1.0);
//
//    vec4 o1 = fract(k3 * (1.0 / 41.0));
//    vec4 o2 = fract(k4 * (1.0 / 41.0));
//
//    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);
//    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);
//
//    return o4.y * d.y + o4.x * (1.0 - d.y);
//}
//

#define OCTAVES 8
float fbm (in vec4 point) {
    // Initial values
    float value = 0.0;
    float amplitude = .5;
    float frequency = 0.;
    // Loop of octaves
    for (int i = 0; i < OCTAVES; i++) {
        value += amplitude * snoise(point);
        point *= 1.9;
        amplitude *= .5;
    }
    return value;
}


vec4 serialize(vec2 ab) {
    // maintaining compatibility with GLSL 2 means we don't get bitwise
    // operators, so we have to do some ugly hacks in here to emulate them
    ivec2 as_ints = ivec2(ab * float(0xFFFF));

    int a_big = as_ints.x / 0xFF;
    int a_lil = as_ints.x - a_big*0xFF;

    int b_big = as_ints.x / 0xFF;
    int b_lil = as_ints.x - a_big*0xFF;

    return vec4(a_big, a_lil, b_big, b_lil) / 255.0;
}


void main() {
    //vec2 pos = vec2(gl_FragCoord.xy/u_resolution.xy);
    vec2 pos = vec2(6.28*gl_FragCoord.xy/128.0);

    float x1 = cos(pos.x);
    float y1 = sin(pos.x);
    float x2 = cos(pos.y) + t/240.0;
    float y2 = sin(pos.y);
    vec4 point = vec4(x1, y1, x2, y2);

    float noise_1 = fbm(point);
    float noise_2 = fbm(point);
    float noise_3 = fbm(point);
    
    gl_FragColor = vec4(noise_1*noise_1, noise_2*0.9, noise_3, 1);
    //gl_FragColor = serialize(vec2(fbm(point), 0));
    //gl_FragColor = vec4(vec3(fbm(point)), 1);
}



    </script>
    <script id="2d-fragment-render-shader" type="notjs">



// fragment shader for rendering RD effect
precision mediump float;

uniform sampler2D u_grayscott;

uniform vec2 u_resolution;


vec2 deserialize(vec4 v) {
    ivec4 as_ints = ivec4(v * float(0xFF));
    return vec2(float(as_ints.r*0xFF + as_ints.g) / 65535.0,
                float(as_ints.b*0xFF + as_ints.a) / 65535.0);
}


void main() {
    //vec2 pos = abs(gl_FragCoord.xy - (u_resolution / vec2(2.0, 0.0)));
    //vec2 col = mod(pos, 64.0) / 64.0;
    //gl_FragColor = vec4(col, 0.5, 1);

    //vec2 ab = deserialize(texture2D(u_grayscott, pos));
    vec2 pos = mod(gl_FragCoord.xy, 256.0)/256.0;
    vec4 ab = texture2D(u_grayscott, pos);
    //if (ab.y == 0.0) gl_FragColor = vec4(1, 0, 0, 1);
    //else gl_FragColor = vec4(0, 1, 0, 1);
    gl_FragColor = ab;
}



    </script>
    <script src="./core.js"></script>  <!-- Load WebGL and set up RD effect -->
</html>
